{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Charon's Little Helper</title>
    <link rel="stylesheet" type="text/css" href="{% static 'styles.css' %}">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

    <style>
        #statistics {
            margin-top: 20px;
            margin: 0 auto;
            text-align: center;
        }
        h2 {
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
        }
        table {
            width: 80%;
            border-collapse: collapse;
            margin: 10px auto;
            background-color: rgba(0, 0, 0, 0.7);
        }
        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background-color: BLACK;
        }

    </style>

</head>
<body>
    <div class="title_a_navbar">
        <h1>Charon's Little Helper</h1>
        <nav>
            <a href="{% url 'import_fits' %}">Import Images</a>
            <a href="{% url 'export_fits' %}">Export Images</a>
        </nav>
    </div>
    <div class="contents">
        <article class="content_part">
            <article id="sky-map"></article>
            <script>
                // parse JSON data
                var skyCoverageData = JSON.parse('{{ sky_coverage_json|safe }}');
                console.log(skyCoverageData);

                // define the view size of the SVG
                var width = 960;  // these are arbitrary; set them to your preferred default size
                var height = 500;

                // create the SVG canvas
                const svg = d3.select("#sky-map").append("svg")
                    .attr("viewBox", `0 0 ${width} ${height}`)
                    .attr("preserveAspectRatio", "xMidYMid meet")
                    .classed("svg-content-responsive", true)
                    .style("background-color", "white");

                var zoom = d3.zoom()
                    .scaleExtent([1, 10])
                    .translateExtent([[0, 0], [width, height]])
                    .on("zoom", zoomed);

                // apply zoom to the SVG
                svg.call(zoom);


                // holds elements we want to zoom
                var g = svg.append("g");

                // define Aitoff projection
                const projection = d3.geoAitoff()
                    .translate([width / 2, height / 2])
                    .scale(width / (2 * Math.PI) - 15);

                // define path generator
                const path = d3.geoPath().projection(projection);

                // define the graticule
                const graticule = d3.geoGraticule()
                    .stepMinor([45, 30]) // adjust this to control the density of grid lines
                    .extent([[-180, -90], [180, 90]]); // full extent of longitude and latitude

                // draw the graticule
                g.append("path")
                    .datum(graticule)
                    .attr("class", "graticule")
                    .attr("d", path)
                    .style("fill", "none")
                    .style("stroke", "black")
                    .style("stroke-width", "0.5")
                    .style("stroke-dasharray", "2,2");

                // define and draw the central meridian and equator with solid lines
                const centralLineData = d3.geoGraticule()
                    .stepMajor([180, 90])  // This will generate only the equator and central meridian
                    .stepMinor([0, 0]);

                g.append("path")
                    .datum(centralLineData)
                    .attr("class", "central-lines")
                    .attr("d", path)
                    .style("fill", "none")
                    .style("stroke", "black")
                    .style("stroke-width", "1px");

                // draw the outline of the projection
                g.append("path")
                    .datum({ type: "Sphere" })
                    .attr("class", "graticule-outline")
                    .attr("d", path)
                    .style("fill", "none")
                    .style("stroke", "black")
                    .style("stroke-width", "1px");

                // longitude degree markers
                const longitudes = d3.range(-180, 181, 45);
                longitudes.forEach((longitude) => {
                    g.append("text")
                      .attr("class", "longitude-label")
                      .attr("x", projection([longitude, 0])[0])
                      .attr("y", projection([longitude, 0])[1])
                      .attr("dy", "1.5em") // Offset the text below the equator
                      .style("text-anchor", "middle")
                      .text(`${longitude}°`);
                });

                // latitude degree markers
                const latitudes = d3.range(-90, 91, 30);
                latitudes.forEach((latitude) => {
                  if (latitude !== 0) { // skip equator so you dont overlap with the 0 from longitudes
                    g.append("text")
                      .attr("class", "latitude-label")
                      .attr("x", projection([0, latitude])[0])
                      .attr("y", projection([0, latitude])[1])
                      .attr("dy", latitude < 0 ? "0em" : "1.5em")
                      .style("text-anchor", "middle")
                      .text(`${latitude}°`);
                  }
                });

                svg.selectAll(".longitude-label, .latitude-label")
                    .style("font-family", "sans-serif")
                    .style("font-size", "10px")
                    .style("paint-order", "stroke")
                    .style("stroke", "white")
                    .style("stroke-width", "1.5px")
                    .style("stroke-linecap", "butt")
                    .style("stroke-linejoin", "miter")
                    .style("fill", "black");

                skyCoverageData.forEach(function(d) {
                    var ra = d.ra - 180;
                    var dec = d.dec;
                    var coordinates = projection([ra, dec]);

                    if (coordinates[0] && coordinates[1]) {
                        // circle to the SVG for each data point
                        g.append("circle")
                            .attr("cx", coordinates[0])
                            .attr("cy", coordinates[1])
                            .attr("r", 2) // radius of the circle
                            .style("fill", "red")
                            .style("opacity", 0.7);
                    }
                });

                function zoomed(event) {
                    g.attr("transform", event.transform);
                }

            </script>


        </article>
    </div>
    </div>
    <div id="statistics">
        <h2>Statistics</h2>
        <table>
                <tr>
                    <td>Number of Nights</td>
                    <td>{{ nights }}</td>
                </tr>
                <tr>
                    <td>Number of Frames</td>
                    <td>{{ frames }}</td>
                </tr>
                <tr>
                    <td>Last Light Frames Night</td>
                    <td>{{ light_frames }}</td>
                </tr>
                <tr>
                    <td>Last Calib Frames Night</td>
                    <td>{{ calib_frames }}</td>
                </tr>
                <tr>
                    <td>Last CCD Temperature</td>
                    <td>{{ CCD_temp }}</td>
                </tr>
        </table>
    </div>
</body>
</html>